#Use our own Scalar
scalar DateTime

type Query {
  avos: [Avocado]!
  avo(id: ID!): Avocado
}

type Mutation {
  createAvo(data: AvoCreateInput!): Avocado!
}

# Creates an entity used as base and which field I want that all my entities has
interface BaseModel {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime
}

type Attributes {
  description: String
  shape: String
  hardiness: String
  taste: String
}

#Main Entity that uses others
type Avocado implements BaseModel {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  deletedAt: DateTime

  name: String!
  sku: String!
  price: Float!
  image: String!
  attributes: Attributes!
}

input AvoCreateInput {
  name: String!
  price: Float!
  image: String!
  description: String
  shape: String
  hardiness: String
  taste: String
}
